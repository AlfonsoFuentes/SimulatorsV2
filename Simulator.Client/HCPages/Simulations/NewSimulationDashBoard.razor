@using GeminiSimulator.Main
@implements IDisposable

@if (Engine != null)
{
    <MudContainer MaxWidth="MaxWidth.False" Class="mt-4">
        <MudPaper Elevation="3" Class="pa-4 mb-4" Style="background-color: #f4f7f9;">
            <MudGrid>
                <MudItem xs="12" md="4">
                    <MudText Typo="Typo.h5" Color="Color.Primary" Style="font-weight: 700;">PROCESS SIMULATOR</MudText>
                    <MudText Typo="Typo.h3" Style="font-family: 'Roboto Mono', monospace; letter-spacing: -2px;">
                        @_displayTime.ToString("HH:mm:ss")
                    </MudText>
                </MudItem>

                <MudItem xs="12" md="4" Class="d-flex justify-center">
                    <MudPaper Outlined="true" Class="pa-2 d-flex align-center" Style="border-radius: 50px;">
                        @if (Engine.Status == EngineStatus.Stopped)
                        {
                            <MudIconButton Icon="@Icons.Material.Filled.PlayArrow" Color="Color.Success" Size="Size.Large" OnClick="StartSimulation" />
                        }
                        else
                        {
                            <MudIconButton Icon="@(Engine.Status == EngineStatus.Paused ? Icons.Material.Filled.PlayArrow : Icons.Material.Filled.Pause)"
                                           Color="Color.Warning" Size="Size.Large" OnClick="TogglePause" />

                            <MudIconButton Icon="@Icons.Material.Filled.Stop" Color="Color.Error" Size="Size.Large" OnClick="StopSimulation" />
                        }
                    </MudPaper>
                </MudItem>

                <MudItem xs="12" md="4">
                    <div class="d-flex align-center">
                        <MudIcon Icon="@Icons.Material.Filled.Speed" Class="mr-2" />
                        <MudText Typo="Typo.caption">SPEED: <b>@Engine.SpeedFactor.ToString("0")x</b></MudText>
                    </div>
                    <MudSlider @bind-Value="Engine.SpeedFactor" Min="1" Max="100" Color="Color.Info" Step="1" />
                </MudItem>
            </MudGrid>
        </MudPaper>

        <MudTabs KeepPanelsAlive="true">
            <MudTabPanel Text="Simulation">
                <SimulationLayout Engine="@Engine" CurrentSnapshot="@LatestSnapshot"></SimulationLayout>
            </MudTabPanel>
            <MudTabPanel Text="Scheduler">
                <SchedulerDashBoard Engine="@Engine" Scheduler="@Scheduler" />
            </MudTabPanel>
            <MudTabPanel Text="Mixer metrics">
                <MixerMetricsDashBoard Engine="@Engine"></MixerMetricsDashBoard>
            </MudTabPanel>
            <MudTabPanel Text="Line metrics">
                <LineMetrixDashBoard Engine="@Engine"></LineMetrixDashBoard>
            </MudTabPanel>
        </MudTabs>
    </MudContainer>
}
else
{
    <MudText Typo="Typo.h5" Color="Color.Primary" Style="font-weight: 700;">Must select production plan</MudText>
}

@code {
    [Parameter] public SimulationEngine Engine { get; set; } = null!;

    // Variables de estado para la UI
    private DateTime _displayTime;
    private SimulationSnapshot? LatestSnapshot;
    private ProductionScheduler? Scheduler;

    // Control de Hilos
    private CancellationTokenSource? _cts;



    override protected void OnInitialized()
    {


    }
    async Task UpdateSimulation()
    {

        await Task.Delay(1);
        _displayTime = Engine.CurrentTime;
        LatestSnapshot = Engine.CurrentSnapshot;
        Scheduler = Engine.Scheduler;
        StateHasChanged();
    }
    protected override void OnParametersSet()
    {
        // Inicialización visual inicial
        if (Engine != null)
        {


            Engine.UpdateModel = UpdateSimulation;
        }
    }

    private async Task StartSimulation()
    {
        if (Engine == null) return;

        // 1. Iniciar token de cancelación para el Engine
        _cts = new CancellationTokenSource();

        // 2. ARRANCAR ENGINE (Fire and Forget seguro)
        // No usamos await aquí para no bloquear la UI. El Engine corre en su Task.
        // Usamos un Progress vacío o nulo si tu Engine lo permite, para no saturar.


        await Engine.RunAsync(_cts);


    }



    private void StopSimulation()
    {
        Engine?.Stop();
        _cts?.Cancel();

    }

    private void TogglePause()
    {
        if (Engine.Status == EngineStatus.Running) Engine.Pause();
        else Engine.Resume();
    }

    public void Dispose()
    {
        _cts?.Cancel();

    }
}